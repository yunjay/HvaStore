"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var introspectionResult_1 = require("../../common/introspectionResult");
var prisma_datamodel_1 = require("prisma-datamodel");
/*
Relational Introspector changes
 [x] Inline relations 1:1 vs 1:n (via unique constraint)
 [ ] Inline relations 1:1 vs 1:n (via data inspection)
 [x] Always add back relations for inline relations
 [x] Correctly handle scalar list tables
 [ ] Add unit test for scalar list table handling
Postgres introspector changes
 [x] Turn string field with isId into ID field
Renderer changes
 [ ] Remove `@relation` if only one relation from A to B
 [ ] Make sorting in renderer optional by parameter
Normalizer changes
 [ ] db/pgColumn directive not picked up correctly
 [x] preserve order of fields and types in respect to ref datamodel
 [ ] Add unit tests for postgres introspection with existing ref datamodel
 [ ] hide createdAt/updatedAt if also hidden in the reference datamodel
 [ ] hide back relations if also hidden in the reference datamodel
 [ ] in v1: handle join tables for 1:n or 1:1 relations correclty, e.g. do not generate a n:n relation in this case
 [ ] migrating v1 to v2: In the case above, add a @relation(link: TABLE) directive.
*/
var RelationalIntrospectionResult = /** @class */ (function (_super) {
    __extends(RelationalIntrospectionResult, _super);
    function RelationalIntrospectionResult(model, relations, enums, databaseType, renderer) {
        var _this = _super.call(this, databaseType, renderer) || this;
        _this.model = model;
        _this.relations = relations;
        _this.enums = enums;
        return _this;
    }
    RelationalIntrospectionResult.prototype.getDatamodel = function () {
        return this.infer(this.model, this.enums, this.relations);
    };
    RelationalIntrospectionResult.prototype.resolveRelations = function (types, relations) {
        var e_1, _a;
        try {
            for (var relations_1 = __values(relations), relations_1_1 = relations_1.next(); !relations_1_1.done; relations_1_1 = relations_1.next()) {
                var relation = relations_1_1.value;
                this.resolveRelation(types, relation);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (relations_1_1 && !relations_1_1.done && (_a = relations_1.return)) _a.call(relations_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return types;
    };
    RelationalIntrospectionResult.prototype.getDatabaseName = function (obj) {
        if (obj.databaseName !== null) {
            return obj.databaseName;
        }
        else {
            return obj.name;
        }
    };
    RelationalIntrospectionResult.prototype.normalizeRelatioName = function (name) {
        if (name.startsWith('_')) {
            return name.substring(1); // This is most likely a prisma relation name
        }
        else {
            return name;
        }
    };
    RelationalIntrospectionResult.prototype.resolveEnumTypes = function (types) {
        var e_2, _a, e_3, _b, e_4, _c;
        try {
            for (var types_1 = __values(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {
                var enumType = types_1_1.value;
                if (!enumType.isEnum)
                    continue;
                try {
                    for (var types_2 = __values(types), types_2_1 = types_2.next(); !types_2_1.done; types_2_1 = types_2.next()) {
                        var type = types_2_1.value;
                        var _loop_1 = function (field) {
                            if (typeof field.type === 'string') {
                                if (field.type === enumType.name) {
                                    // Remove type error hint and set enum type
                                    field.comments = field.comments.filter(function (comment) {
                                        return comment.text !== "Type " + field.type + " is not supported";
                                    });
                                    field.type = enumType;
                                }
                            }
                        };
                        try {
                            for (var _d = __values(type.fields), _e = _d.next(); !_e.done; _e = _d.next()) {
                                var field = _e.value;
                                _loop_1(field);
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (types_2_1 && !types_2_1.done && (_b = types_2.return)) _b.call(types_2);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (types_1_1 && !types_1_1.done && (_a = types_1.return)) _a.call(types_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return types;
    };
    RelationalIntrospectionResult.prototype.resolveRelation = function (types, relation) {
        var e_5, _a, e_6, _b, e_7, _c, e_8, _d;
        try {
            // Correctly sets field types according to given FK constraints.
            for (var types_3 = __values(types), types_3_1 = types_3.next(); !types_3_1.done; types_3_1 = types_3.next()) {
                var typeA = types_3_1.value;
                try {
                    for (var types_4 = __values(types), types_4_1 = types_4.next(); !types_4_1.done; types_4_1 = types_4.next()) {
                        var typeB = types_4_1.value;
                        try {
                            for (var _e = __values(typeA.fields), _f = _e.next(); !_f.done; _f = _e.next()) {
                                var fieldA = _f.value;
                                try {
                                    for (var _g = __values(typeB.fields), _h = _g.next(); !_h.done; _h = _g.next()) {
                                        var fieldB = _h.value;
                                        if (relation.sourceColumn === this.getDatabaseName(fieldA) &&
                                            relation.sourceTable === this.getDatabaseName(typeA) &&
                                            relation.targetColumn === this.getDatabaseName(fieldB) &&
                                            relation.targetTable === this.getDatabaseName(typeB)) {
                                            if (!fieldB.isId) {
                                                prisma_datamodel_1.GQLAssert.raise("Relation " + typeA.name + "." + fieldA.name + " -> " + typeB.name + "." + fieldB.name + " does not target the PK column of " + typeB.name);
                                            }
                                            fieldA.type = typeB;
                                            // TODO: We could look at the data to see if this is 1:1 or 1:n. For now, we use a unique constraint. Tell Tim.
                                            // Add back connecting field
                                            var connectorFieldAtB = {
                                                // TODO - how do we name that field?
                                                // Problems:
                                                // * Conflicts
                                                // * Need to identify field in existing datamodel to fix naming, fix cardinality or hide
                                                name: prisma_datamodel_1.camelCase(typeA.name),
                                                databaseName: null,
                                                defaultValue: null,
                                                isList: fieldA.isUnique,
                                                isCreatedAt: false,
                                                isUpdatedAt: false,
                                                isId: false,
                                                isReadOnly: false,
                                                isRequired: fieldA.isRequired,
                                                isUnique: false,
                                                relatedField: fieldA,
                                                type: typeA,
                                                relationName: null,
                                                comments: [],
                                                directives: [],
                                            };
                                            // Hook up connector fields
                                            fieldA.relatedField = connectorFieldAtB;
                                            typeB.fields.push(connectorFieldAtB);
                                            return;
                                        }
                                    }
                                }
                                catch (e_8_1) { e_8 = { error: e_8_1 }; }
                                finally {
                                    try {
                                        if (_h && !_h.done && (_d = _g.return)) _d.call(_g);
                                    }
                                    finally { if (e_8) throw e_8.error; }
                                }
                            }
                        }
                        catch (e_7_1) { e_7 = { error: e_7_1 }; }
                        finally {
                            try {
                                if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                            }
                            finally { if (e_7) throw e_7.error; }
                        }
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (types_4_1 && !types_4_1.done && (_b = types_4.return)) _b.call(types_4);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (types_3_1 && !types_3_1.done && (_a = types_3.return)) _a.call(types_3);
            }
            finally { if (e_5) throw e_5.error; }
        }
        prisma_datamodel_1.GQLAssert.raise("Failed to resolve FK constraint " + relation.sourceTable + "." + relation.sourceColumn + " -> " + relation.targetTable + "." + relation.targetColumn + ".");
    };
    RelationalIntrospectionResult.prototype.hideScalarListTypes = function (types) {
        var e_9, _a;
        var scalarListTypes = [];
        var _loop_2 = function (type) {
            var e_10, _a;
            try {
                for (var _b = __values(type.fields), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var field = _c.value;
                    if (typeof field.type === 'string')
                        continue;
                    var candidate = field.type;
                    // A type is only a scalar list iff it has
                    // * name of ${type.name}_${field.name}
                    // * Has exactly three fields
                    //     * nodeId: typeof type!
                    //     * position: Int!
                    //     * value: ?
                    // TODO: Tim mentioned, but not observed in the wild.
                    // * compound index over nodeId and position
                    if (candidate.fields.length !== 3)
                        continue;
                    if (candidate.name === type.name + "_" + field.name)
                        continue;
                    var _d = __read(candidate.fields.filter(function (field) {
                        return field.name === 'nodeId' &&
                            field.type === type &&
                            field.isRequired == true &&
                            field.isList === false;
                    }), 1), nodeId = _d[0];
                    var _e = __read(candidate.fields.filter(function (field) {
                        return field.name === 'position' &&
                            field.type === prisma_datamodel_1.TypeIdentifiers.integer &&
                            field.isRequired == true &&
                            field.isList === false;
                    }), 1), position = _e[0];
                    var _f = __read(candidate.fields.filter(function (field) {
                        return field.name === 'value' &&
                            field.isRequired == true &&
                            field.isList === false;
                    }), 1), value = _f[0];
                    if (nodeId === undefined ||
                        position === undefined ||
                        value === undefined)
                        continue;
                    // If we got so far, we have found a scalar list type. Hurray!
                    scalarListTypes.push(candidate);
                    // Update the field to show a scalar list
                    field.type = value.type;
                    field.isList = true;
                    // Update the name, if it follows prisma conventions
                    // e.g. user_scalarIntList => scalarIntList
                    if (field.name.startsWith(prisma_datamodel_1.camelCase(type.name) + "_")) {
                        field.name = field.name.substring(type.name.length + 1);
                    }
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_10) throw e_10.error; }
            }
        };
        try {
            for (var types_5 = __values(types), types_5_1 = types_5.next(); !types_5_1.done; types_5_1 = types_5.next()) {
                var type = types_5_1.value;
                _loop_2(type);
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (types_5_1 && !types_5_1.done && (_a = types_5.return)) _a.call(types_5);
            }
            finally { if (e_9) throw e_9.error; }
        }
        // Filter out scalar list types
        return types.filter(function (type) { return !scalarListTypes.includes(type); });
    };
    /**
     * Removes all types which are only there for NM relations
     * @param types
     */
    RelationalIntrospectionResult.prototype.hideJoinTypes = function (types) {
        var e_11, _a;
        var nonJoinTypes = [];
        var _loop_3 = function (type) {
            var relationFields = type.fields.filter(function (field) { return typeof field.type !== 'string'; });
            var relationAndIdFields = type.fields.filter(function (field) { return typeof field.type !== 'string' || field.isId; });
            // A join type only as two relation fields. And sometimes a primary key.
            var isJoinType = (relationFields.length === 2 && type.fields.length === 2) ||
                (relationAndIdFields.length === 3 && type.fields.length === 3);
            if (isJoinType) {
                // We drop the join type, but add a n:m relation to
                // the two related tables.
                var _a = __read(relationFields, 2), relA = _a[0], relB = _a[1];
                // Type checking was done above
                var typeA = relA.type;
                var typeB = relB.type;
                var relatedFieldForA = {
                    name: typeB.name,
                    type: typeB,
                    isList: true,
                    isUnique: false,
                    isId: false,
                    isCreatedAt: false,
                    isUpdatedAt: false,
                    isRequired: true,
                    isReadOnly: false,
                    comments: [],
                    directives: [],
                    defaultValue: null,
                    relatedField: null,
                    databaseName: null,
                    relationName: this_1.normalizeRelatioName(type.name),
                };
                var relatedFieldForB = {
                    name: typeA.name,
                    type: typeA,
                    isList: true,
                    isUnique: false,
                    isId: false,
                    isCreatedAt: false,
                    isUpdatedAt: false,
                    isRequired: true,
                    isReadOnly: false,
                    comments: [],
                    directives: [],
                    defaultValue: null,
                    relatedField: relatedFieldForA,
                    databaseName: null,
                    relationName: this_1.normalizeRelatioName(type.name),
                };
                relatedFieldForA.relatedField = relatedFieldForB;
                typeA.fields.push(relatedFieldForA);
                typeA.fields = typeA.fields.filter(function (x) { return x.type !== type; });
                typeB.fields = typeB.fields.filter(function (x) { return x.type !== type; });
                typeB.fields.push(relatedFieldForB);
            }
            else {
                nonJoinTypes.push(type);
            }
        };
        var this_1 = this;
        try {
            for (var types_6 = __values(types), types_6_1 = types_6.next(); !types_6_1.done; types_6_1 = types_6.next()) {
                var type = types_6_1.value;
                _loop_3(type);
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (types_6_1 && !types_6_1.done && (_a = types_6.return)) _a.call(types_6);
            }
            finally { if (e_11) throw e_11.error; }
        }
        return nonJoinTypes;
    };
    /**
     * Hides indices on related fields. These are always autmatically created by
     * prisma and dont need to be shown in the datamodel.
     * @param types
     */
    RelationalIntrospectionResult.prototype.hideIndicesOnRelatedFields = function (types) {
        var e_12, _a;
        try {
            for (var types_7 = __values(types), types_7_1 = types_7.next(); !types_7_1.done; types_7_1 = types_7.next()) {
                var type = types_7_1.value;
                // Keep indices which have not exactly one field, or if they have one field,
                // the field is a scalar field.
                type.indices = type.indices.filter(function (index) {
                    return index.fields.length !== 1 || typeof index.fields[0].type === 'string';
                });
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (types_7_1 && !types_7_1.done && (_a = types_7.return)) _a.call(types_7);
            }
            finally { if (e_12) throw e_12.error; }
        }
        return types;
    };
    /**
     * Hides unique inidices and marks the corresponding fields as unique instead.
     * @param types
     */
    RelationalIntrospectionResult.prototype.hideUniqueIndices = function (types) {
        var e_13, _a, e_14, _b;
        try {
            for (var types_8 = __values(types), types_8_1 = types_8.next(); !types_8_1.done; types_8_1 = types_8.next()) {
                var type = types_8_1.value;
                var uniqueIndices = type.indices.filter(function (index) { return index.fields.length === 1 && index.unique; });
                var _loop_4 = function (uniqueIndex) {
                    uniqueIndex.fields[0].isUnique = true;
                    type.indices = type.indices.filter(function (x) { return x !== uniqueIndex; });
                };
                try {
                    for (var uniqueIndices_1 = __values(uniqueIndices), uniqueIndices_1_1 = uniqueIndices_1.next(); !uniqueIndices_1_1.done; uniqueIndices_1_1 = uniqueIndices_1.next()) {
                        var uniqueIndex = uniqueIndices_1_1.value;
                        _loop_4(uniqueIndex);
                    }
                }
                catch (e_14_1) { e_14 = { error: e_14_1 }; }
                finally {
                    try {
                        if (uniqueIndices_1_1 && !uniqueIndices_1_1.done && (_b = uniqueIndices_1.return)) _b.call(uniqueIndices_1);
                    }
                    finally { if (e_14) throw e_14.error; }
                }
            }
        }
        catch (e_13_1) { e_13 = { error: e_13_1 }; }
        finally {
            try {
                if (types_8_1 && !types_8_1.done && (_a = types_8.return)) _a.call(types_8);
            }
            finally { if (e_13) throw e_13.error; }
        }
        return types;
    };
    RelationalIntrospectionResult.prototype.hideReservedTypes = function (types) {
        var _this = this;
        return types.filter(function (x) { return !_this.isTypeReserved(x); });
    };
    RelationalIntrospectionResult.prototype.infer = function (model, enums, relations) {
        var _this = this;
        // TODO: Maybe we want to have a concept of hidden, which just skips rendering?
        // Ask tim, this is an important descision for the SDK
        var types = __spread(model.map(function (x) { return _this.inferObjectType(x); }), enums.map(function (x) { return _this.inferEnumType(x); }));
        types = this.resolveRelations(types, relations);
        types = this.resolveEnumTypes(types);
        types = this.hideJoinTypes(types);
        types = this.hideReservedTypes(types);
        types = this.hideScalarListTypes(types);
        types = this.hideUniqueIndices(types);
        types = this.hideIndicesOnRelatedFields(types);
        types = this.hideJoinTypes(types);
        return {
            comments: [],
            types: types,
        };
    };
    RelationalIntrospectionResult.prototype.inferIndex = function (index, fields) {
        var fieldCandidates = fields.filter(function (field) {
            return index.fields.filter(function (indexField) { return field.name === indexField; }).length > 0;
        });
        return {
            fields: fieldCandidates,
            name: index.name,
            unique: index.unique,
        };
    };
    RelationalIntrospectionResult.prototype.inferEnumType = function (model) {
        var values = model.values.map(function (x) { return ({
            name: x,
            isCreatedAt: false,
            isId: false,
            isList: false,
            isReadOnly: false,
            isRequired: false,
            isUnique: false,
            isUpdatedAt: false,
            relatedField: null,
            relationName: null,
            type: prisma_datamodel_1.TypeIdentifiers.string,
            defaultValue: null,
            databaseName: null,
            directives: [],
            comments: [],
        }); });
        return {
            name: model.name,
            fields: values,
            isEnum: true,
            isEmbedded: false,
            databaseName: null,
            comments: [],
            directives: [],
            indices: [],
        };
    };
    RelationalIntrospectionResult.prototype.inferObjectType = function (model) {
        var _this = this;
        var e_15, _a, e_16, _b;
        var fields = model.columns.map(function (x) { return _this.inferField(x); });
        var indices = model.indices.map(function (x) { return _this.inferIndex(x, fields); });
        // Resolve primary key
        if (model.primaryKey !== null) {
            var pk_1 = model.primaryKey;
            if (pk_1.fields.length === 1) {
                // Single PK field - prisma can do that
                var _c = __read(fields.filter(function (field) { return field.name === pk_1.fields[0]; }), 1), pkField = _c[0];
                if (!pkField) {
                    prisma_datamodel_1.GQLAssert.raise("Index/Schema missmatch during introspection. Field " + pk_1.fields[0] + " used in index, but does not exist on table " + model.name);
                }
                // Hard rename ID field to match old datamodel standard
                if (pkField.name !== 'id') {
                    pkField.databaseName = pkField.name;
                    pkField.name = 'id';
                }
                pkField.isId = true;
            }
            else {
                try {
                    // Compound PK - that's not supported
                    for (var _d = __values(pk_1.fields), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var pkFieldName = _e.value;
                        var _f = __read(fields.filter(function (field) { return field.name === pk_1.fields[0]; }), 1), pkField = _f[0];
                        if (!pkField) {
                            prisma_datamodel_1.GQLAssert.raise("Index/Schema missmatch during introspection. Field " + pk_1.fields[0] + " used in index, but does not exist on table " + model.name);
                        }
                        pkField.isId = true;
                        pkField.comments.push({
                            text: "Multiple ID fields (compound indexes) are not supported",
                            isError: true,
                        });
                    }
                }
                catch (e_15_1) { e_15 = { error: e_15_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                    }
                    finally { if (e_15) throw e_15.error; }
                }
            }
        }
        try {
            // We need info about indices for resolving the exact type, as String is mapped to ID.
            // Also, we need info about the actual type before we resolve default values.
            for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
                var field = fields_1_1.value;
                this.inferFieldTypeAndDefaultValue(field, model.name);
            }
        }
        catch (e_16_1) { e_16 = { error: e_16_1 }; }
        finally {
            try {
                if (fields_1_1 && !fields_1_1.done && (_b = fields_1.return)) _b.call(fields_1);
            }
            finally { if (e_16) throw e_16.error; }
        }
        return {
            name: model.name,
            isEmbedded: false,
            isEnum: false,
            fields: fields,
            indices: indices,
            directives: [],
            comments: [],
            databaseName: null,
        };
    };
    RelationalIntrospectionResult.prototype.inferField = function (field) {
        var comments = [];
        if (field.comment !== null) {
            comments.push({
                text: field.comment,
                isError: false,
            });
        }
        var gqlField = {
            name: field.name,
            isUnique: field.isUnique,
            isRequired: !field.isNullable,
            defaultValue: field.defaultValue,
            isList: field.isList,
            type: field.type,
            isId: false,
            relatedField: null,
            relationName: null,
            isCreatedAt: false,
            isUpdatedAt: false,
            isReadOnly: false,
            comments: comments,
            directives: [],
            databaseName: null,
        };
        return gqlField;
    };
    RelationalIntrospectionResult.prototype.inferFieldTypeAndDefaultValue = function (field, typeName) {
        prisma_datamodel_1.GQLAssert.raiseIf(typeof field.type !== 'string', 'Must be called before resolving relations');
        var type = this.toTypeIdentifyer(field.type, field, typeName);
        if (type === null) {
            field.comments.push({
                text: "Type " + field.type + " is not supported",
                isError: true,
            });
            // Keep native type and register an error.
        }
        else {
            field.type = type;
        }
        if (field.defaultValue !== null) {
            prisma_datamodel_1.GQLAssert.raiseIf(typeof field.defaultValue !== 'string', 'Must be called with unparsed default values.');
            field.defaultValue = this.parseDefaultValue(field.defaultValue, field.type);
        }
    };
    return RelationalIntrospectionResult;
}(introspectionResult_1.IntrospectionResult));
exports.RelationalIntrospectionResult = RelationalIntrospectionResult;
//# sourceMappingURL=relationalIntrospectionResult.js.map